[
  {
    "page": 1,
    "bbox": null,
    "text": "Unit 1: Basics of Python Programming\n\n1. Two Sum (1)\n\nGiven an array of integers nums and an integer target, return indices of the two numbers\nsuch that they add up to target.You may assume that each input would have exactly one\nsolution, and you may not use the same element twice.You can return the answer in any\norder.\n\nExample 1:\n\nInput: nums = [2,7,11,15], target = 9\n\nOutput: [0,1]\n\nExplanation: Because nums[0] + nums[1] == 9, we return [0, 1].\n\nExample 2:\n\nInput: nums = [3,2,4], target = 6\n\nOutput: [1,2]\n\nExample 3:\n\nInput: nums = [3,3], target = 6\n\nOutput: [0,1]\n\n2.Contains Duplicate (217)\n\nGiven an integer array nums, return true if any value appears at least twice in the array, and\nreturn false if every element is distinct.\nExample 1:\n\nInput: nums = [1,2,3,1]\n\nOutput: true\n\nExplanation:\n\nThe element 1 occurs at the indices O and 3.\nExample 2:\n\nInput: nums = [1,2,3,4]\n\nOutput: false\n\nExplanation:\n\nAll elements are distinct.\n\nExample 3:\n\nInput: nums = [1,1,1,3,3,4,3,2,4,2]\n\nOutput: true\n\n3.Single Number (136)\n\nGiven a non-empty array of integers nums, every element appears twice except for one.\nFind that single one.\n\nYou must implement a solution with a linear runtime complexity and use only constant extra\nspace.(136)\n\nExample 1:\n\nInput: nums = [2,2,1]\n\nOutput: 1",
    "type": "text"
  },
  {
    "page": 2,
    "bbox": null,
    "text": "Example 2:\n\nInput: nums = [4,1,2,1,2]\nOutput: 4\n\nExample 3:\n\nInput: nums = [1]\nOutput: 1\n\n4.Intrsection of Two Arrays (350)\n\nGiven two integer arrays nums1 and numsz2, return an array of their intersection. Each\nelement in the result must appear as many times as it shows in both arrays and you may\nreturn the result in any order.\n\nExample 1:\n\nInput: nums1 = [1,2,2,1], nums2 = [2,2]\n\nOutput: [2,2]\n\nExample 2:\n\nInput: nums1 = [4,9,5], nums2 = [9,4,9,8,4]\n\nOutput: [4,9]\n\nExplanation: [9,4] is also accepted.\n\n5.N-ary Tree Preorder Traversal (589)\n\nGiven the root of an n-ary tree, return the preorder traversal of its nodes' values.\nNary-Tree input serialization is represented in their level order traversal. Each group of\nchildren is separated by the null value (See examples)\n\nExample 1:\n\nInput: root = [1,null,3,2,4,null,5,6]\n\nOutput: [1,3,5,6,2,4]\n\nExample 2:\n\nInput: root =\n[1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]\nOutput: [1,2,3,6,7,11,14,4,8,12,5,9,13,10]\n\n6.Pascal’s Triangle (118)\n\nGiven an integer numRows, return the first numRows of Pascal's triangle.\n\nIn Pascal's triangle, each number is the sum of the two numbers directly above it as shown:\nExample 1:\n\nInput: numRows = 5\n\nOutput: [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]\n\nExample 2:\n\nInput: numRows = 1\n\nOutput: [[1]]\n\n7.Best Time to Buy and Sell Stock (121)\n\nYou are given an array prices where prices|i] is the price of a given stock on the i” day.\nYou want to maximize your profit by choosing a single day to buy one stock and choosing\na different day in the future to sell that stock.\n\nReturn the maximum profit you can achieve from this transaction. lf you cannot achieve any\nprofit, return 0.",
    "type": "text"
  },
  {
    "page": 3,
    "bbox": null,
    "text": "Example 1:\n\nInput: prices = [7,1,5,3,6,4]\n\nOutput: 5\n\nExplanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.\n\nNote that buying on day 2 and selling on day 1 is not allowed because you must buy before\nyou sell.\n\nExample 2:\n\nInput: prices = [7,6,4,3,1]\n\nOutput: 0\n\nExplanation: In this case, no transactions are done and the max profit = 0.\n\n8.Reverse String (344)\n\nWrite a function that reverses a string. The input string is given as an array of characters s.\nYou must do this by modifying the input array in-place with O(1) extra memory.\n\nExample 1:\n\nInput: s =[\"h\",\"e\", \"1, \"1\",\"0\"7\n\nOutput: [\"o\",\"1\",\"1\",\"e\",\"h\"]\n\nExample 2:\n\nInput: s =[\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"]\n\nOutput: [\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"]\n\n9.Word Pattern (290)\nGiven a pattern and a string s, find if s follows the same pattern.\nHere follow means a full match, such that there is a bijection between a letter in pattern and\na non-empty word in s. Specifically:\n\ne Each letter in pattern maps to exactly one unique word in s.\n\ne Each unique word in s maps to exactly one letter in pattern.\n\ne No two letters map to the same word, and no two words map to the same letter.\nExample 1:\nInput: pattern = \"abba\", s = \"dog cat cat dog'\nOutput: true\nExplanation:\nThe bijection can be established as:\n\ne ‘a' maps to \"dog\".\n\ne 'b' maps to \"cat\".\nExample 2:\nInput: pattern = \"abba\", s = \"dog cat cat fish\"\nOutput: false\nExample 3:\nInput: pattern = \"aaaa\", s = \"dog cat cat dog\"\nOutput: false",
    "type": "text"
  },
  {
    "page": 4,
    "bbox": null,
    "text": "10. Design HashSet (705)\nDesign a HashSet without using any built-in hash table libraries.\nImplement MyHashSet class:\ne void add(key) Inserts the value key into the HashSet.\ne bool contains(key) Returns whether the value key exists in the HashSet or not.\ne void remove(key) Removes the value key in the HashSet. If key does not exist in the\nHashSet, do nothing.\nExample 1:\nInput\n[\"MyHashSet\", \"add\", \"add\", \"contains\", \"contains\", \"add\", \"contains\", \"remove\", \"\n([], (2), (21, [2], (3), (21, [2], [2], [20]\nOutput\n[null, null, null, true, false, null, true, null, false]\nExplanation\nMyHashSet myHashSet = new MyHashSet();\nmyHashSet.add(1);  // set = [1]\nmyHashSet.add(2); //set = [1, 2]\nmyHashSet.contains(1); // return True\nmyHashSet.contains(3); // return False, (not found)\nmyHashSet.add(2);  // set = [1, 2]\nmyHashSet.contains(2); // return True\nmyHashSet.remove(2); // set = [1]\nmyHashSet.contains(2); // return False, (already removed)\n\ncontains\"]\n\n11.Valid Anagram (242)\n\nGiven two strings s and t, return true if t is an anagram of s, and false otherwise.\nExample 1:\n\nInput: s = \"anagram\", t = \"nagaram\"\n\nOutput: true\n\nExample 2:\n\nInput: s = \"rat\", t = \"car\"\n\nOutput: false\n\n12.N-ary Tree Preorder Traversal (589)\n\nGiven the root of an n-ary tree, return the preorder traversal of its nodes' values.\nNary-Tree input serialization is represented in their level order traversal. Each group of\nchildren is separated by the null value (See examples)\n\nExample 1:\n\nInput: root = [1,null,3,2,4,null,5,6]\n\nOutput: [1,3,5,6,2,4]\n\nExample 2:\n\nInput: root =\n[1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]\nOutput: [1,2,3,6,7,11,14,4,8,12,5,9,13,10]",
    "type": "text"
  },
  {
    "page": 5,
    "bbox": null,
    "text": "13.Construct Binary Tree from Preorder and Inorder Traversal (105)\n\nGiven two integer arrays preorder and inorder where preorder is the preorder traversal of a\nbinary tree and inorder is the inorder traversal of the same tree, construct and return the\nbinary tree.\n\nExample 1:\n\nInput: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]\n\nOutput: [3,9,20,null,null,15,7]\n\nExample 2:\n\nInput: preorder = [-1], inorder = [-1]\n\nOutput: [-1]\n\n14. 3Sum (15)\n\nGiven an integer array nums, return all the triplets [nums[i], nums|j], nums[k]] such that i !=\nj,i !=k, andj !=k, and nums[i] + nums[j] + nums[k] == 0.\n\nNotice that the solution set must not contain duplicate triplets.\n\nExample 1:\n\nInput: nums = [-1,0,1,2,-1,-4]\n\nOutput: [[-1,-1,2],[-1,0,1]]\n\nExplanation:\n\nnums[0O] + nums[1] + nums[2] = (-1)+0+1=0.\n\nnums[1] + nums[2] + nums[4] = 0+ 1+ (-1) =0.\n\nnums[0O] + nums[3] + nums[4] = (-1) + 2 + (-1) =0.\n\nThe distinct triplets are [-1,0,1] and [-1,-1,2].\n\nNotice that the order of the output and the order of the triplets does not matter.\n\nExample 2:\n\nInput: nums = [0,1,1]\n\nOutput: []\n\nExplanation: The only possible triplet does not sum up to 0.\nExample 3:\n\nInput: nums = [0,0,0]\nOutput: [[0,0,0]]\nExplanation: The only possible triplet sums up to 0.\n\n15.Plus One (66)\n\nYou are given a large integer represented as an integer array digits, where each digits|i] is\nthe it\" digit of the integer. The digits are ordered from most significant to least significant in\nleft-to-right order. The large integer does not contain any leading 0's.\n\nIncrement the large integer by one and return the resulting array of digits.\n\nExample 1:\n\nInput: digits = [1,2,3]\n\nOutput: [1,2,4]\n\nExplanation: The array represents the integer 123.\n\nincrementing by one gives 123 + 1 = 124.\n\nThus, the result should be [1,2,4].\n\nExample 2:\n\nInput: digits = [4,3,2,1]\n\nOutput: [4,3,2,2]",
    "type": "text"
  },
  {
    "page": 6,
    "bbox": null,
    "text": "Explanation: The array represents the integer 4321.\nIncrementing by one gives 4321 + 1 = 4322.\n\nThus, the result should be [4,3,2,2].\n\nExample 3:\n\nInput: digits = [9]\n\nOutput: [1,0]\n\nExplanation: The array represents the integer 9.\nIncrementing by one gives 9+ 1=10.\n\nThus, the result should be [1,0].\n\n16.Pascal’s Triangle (118)\n\nGiven an integer numRows, return the first numRows of Pascal's triangle.\n\nIn Pascal's triangle, each number is the sum of the two numbers directly above it as shown:\nExample 1:\n\nInput: numRows = 5\n\nOutput: [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]\n\nExample 2:\n\nInput: numRows = 1\n\nOutput: [[1]]\n\n17.Longest Substring Without Repeating Characters (3)\n\nGiven a string s, find the length of the longest substring without duplicate characters.\nExample 1:\n\nInput: s = \"abcabcbb\"\n\nOutput: 3\n\nExplanation: The answer is \"abc\", with the length of 3.\n\nExample 2:\n\nInput: s = \"bbbbb\"\n\nOutput: 1\n\nExplanation: The answer is \"b\", with the length of 1.\n\nExample 3:\n\nInput: s = \"pwwkew\"\n\nOutput: 3\n\nExplanation: The answer is \"wke\", with the length of 3.\n\nNotice that the answer must be a substring, \"pwke\" is a subsequence and not a substring.\n\n18.First Unique Character in a String (387)\n\nGiven a string s, find the first non-repeating character in it and return its index. If it does\nnot exist, return -1.\n\nExample 1:\n\nInput: s = \"leetcode\"\n\nOutput: 0\n\nExplanation:\n\nThe character 'l' at index 0 is the first character that does not occur at any other index.\nExample 2:\n\nInput: s = \"loveleetcode\"\n\nOutput: 2",
    "type": "text"
  },
  {
    "page": 7,
    "bbox": null,
    "text": "Example 3:\nInput: s = \"aabb\"\nOutput: -1\n\n19.Group Anagrams (49)\n\nGiven a string s, find the first non-repeating character in it and return its index. If it does\nnot exist, return -1.\n\nExample 1:\n\nInput: s = \"leetcode\"\n\nOutput: 0\n\nExplanation:\n\nThe character 'l' at index 0 is the first character that does not occur at any other index.\nExample 2:\n\nInput: s = \"loveleetcode\"\n\nOutput: 2\n\nExample 3:\n\nInput: s = \"aabb\"\n\nOutput: -1\n\n20.Intersection of Two Arrays (350)\n\nGiven two integer arrays nums1 and numsz2, return an array of their intersection. Each\nelement in the result must appear as many times as it shows in both arrays and you may\nreturn the result in any order.\n\nExample 1:\n\nInput: nums1 = [1,2,2,1], nums2 = [2,2]\n\nOutput: [2,2]\n\nExample 2:\n\nInput: nums1 = [4,9,5], nums2 = [9,4,9,8,4]\n\nOutput: [4,9]\n\nExplanation: [9,4] is also accepted.",
    "type": "header"
  }
]